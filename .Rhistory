mvsim <- function(x,prob,beta,covar){
n = dim(x)[1]
m = ncol(covar)
y = matrix(0,n,m)
for (i in 1:n){
y[i,] = rmvnorm(1,mean=x[i,]%*%beta,sigma=covar)
}
y
}
set.seed(13)
n <- 10   # nr of observation
p <- 80  # nbr of component of x
m  <- 2 # nbr of component of y
k <- 1
#x <- cbind(rep(1,n),matrix(rnorm(n*p),n,p))
x <- matrix(rnorm(n*p),n,p)
prob = 1
beta <- array(0, dim = c(p,m))
#beta[,,1] <- rbind(c(0,0),c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
beta <- rbind(c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
covar <- array(0, dim = c(m,m))
covar <- matrix(c(2,1,1,2),2,2)
y <- mvsim(x=x,covar=covar,beta=beta,prob=prob)
fit <- JointSol(y,x,lambda=0.05)
P.est <- fit$P
Phi.est <- fit$Phi
la <- seq(0.05,0.3,length=11)
fdml <- dmlpath(x,y,lambda = la)
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
fdml <- dmlpath(x,y,lambda = la)
rm(list=ls())
setwd("~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized")
gc(TRUE)
source("JointSol_rep.R","mvnorm.R")
source("JointSol_rep.R",
"mvnorm.R")
?source
rm(list=ls())
setwd("~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized")
gc(TRUE)
source("JointSol_rep.R")
source ("mvnorm.R")
source("cv_dml.R")
"%^%" =  function(x, n)
mvsim <- function(x,prob,beta,covar){
n = dim(x)[1]
m = ncol(covar)
y = matrix(0,n,m)
for (i in 1:n){
y[i,] = rmvnorm(1,mean=x[i,]%*%beta,sigma=covar)
}
y
}
set.seed(13)
n <- 10   # nr of observation
p <- 80  # nbr of component of x
m  <- 2 # nbr of component of y
k <- 1
#x <- cbind(rep(1,n),matrix(rnorm(n*p),n,p))
x <- matrix(rnorm(n*p),n,p)
prob = 1
beta <- array(0, dim = c(p,m))
#beta[,,1] <- rbind(c(0,0),c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
beta <- rbind(c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
covar <- array(0, dim = c(m,m))
covar <- matrix(c(2,1,1,2),2,2)
y <- mvsim(x=x,covar=covar,beta=beta,prob=prob)
mvsim <- function(x,prob,beta,covar){
n = dim(x)[1]
m = ncol(covar)
y = matrix(0,n,m)
for (i in 1:n){
y[i,] = rmvnorm(1,mean=x[i,]%*%beta,sigma=covar)
}
y
}
set.seed(13)
n <- 10   # nr of observation
p <- 80  # nbr of component of x
m  <- 2 # nbr of component of y
k <- 1
#x <- cbind(rep(1,n),matrix(rnorm(n*p),n,p))
x <- matrix(rnorm(n*p),n,p)
prob = 1
beta <- array(0, dim = c(p,m))
#beta[,,1] <- rbind(c(0,0),c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
beta <- rbind(c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
covar <- array(0, dim = c(m,m))
covar <- matrix(c(2,1,1,2),2,2)
y <- mvsim(x=x,covar=covar,beta=beta,prob=prob)
fit <- JointSol(y,x,lambda=0.05)
la <- seq(0.05,0.3,length=11)
fdml <- dmlpath(x,y,lambda = la)
la
la[1]
la[2]
la[5]
for (i  in 1:11){
maa[i] <- JointSol(y,x,lambda = la[i])
}
maa
maa = array()
for (i  in 1:11){
maa[i] <- JointSol(y,x,lambda = la[i])
}
maa
dimnames(maa)
fit <- JointSol(y,x,lambda=0.05)
dimnames(fit)
maa[1]$P
maa[1]$Phi
maa = array()
maas = array()
for (i  in 1:11){
maa[i] <- JointSol(y,x,lambda = la[i])$Phi
maas[i] <- JoinSol(y,x,lambda = lap[i])$P
}
for (i  in 1:11){
maa[i] <- JointSol(y,x,lambda = la[i])$Phi
maas[i] <- JointSol(y,x,lambda = lap[i])$P
}
for (i  in 1:11){
maa[i] <- JointSol(y,x,lambda = la[i])$Phi
maas[i] <- JointSol(y,x,lambda = la[i])$P
}
maa
maas
JointSol(x,y,lambda = 0.15)
??lars
JointSol(x,y,lambda = 0.2)
JointSol(x,y,lambda = 0.05)
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
fdml <- dmlpath(x,y,lambda = la)
fdml <- dmlpath(y,x,lambda = la)
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
fdml <- dmlpath(y,x,lambda = la)
JointSol(y,x,lambda = 0.15)
rm(list=ls())
setwd("~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized")
gc(TRUE)
source("JointSol_rep.R")
source ("mvnorm.R")
source("cv_dml.R")
"%^%" =  function(x, n)
with(eigen(x), vectors %*% (values^n * t(vectors)))
mvsim <- function(x,prob,beta,covar){
n = dim(x)[1]
m = ncol(covar)
y = matrix(0,n,m)
for (i in 1:n){
y[i,] = rmvnorm(1,mean=x[i,]%*%beta,sigma=covar)
}
y
}
set.seed(13)
n <- 10   # nr of observation
p <- 80  # nbr of component of x
m  <- 2 # nbr of component of y
k <- 1
#x <- cbind(rep(1,n),matrix(rnorm(n*p),n,p))
x <- matrix(rnorm(n*p),n,p)
prob = 1
beta <- array(0, dim = c(p,m))
#beta[,,1] <- rbind(c(0,0),c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
beta <- rbind(c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
covar <- array(0, dim = c(m,m))
covar <- matrix(c(2,1,1,2),2,2)
y <- mvsim(x=x,covar=covar,beta=beta,prob=prob)
fit <- JointSol(y,x,lambda=0.05)
P.est <- fit$P
Phi.est <- fit$Phi
la <- seq(0.05,0.3,length=11)
fdml <- dmlpath(y,x,lambda = la)
maas <- array(
maas <- array()
maa <- array()
maas <- array()
for (i  in 1:11){
maa[i] <- JointSol(y,x,lambda = la[i])$Phi
maas[i] <- JointSol(y,x,lambda = la[i])$P
}
for (i  in 1:11){
maa[i] <- JointSol(y,x,lambda = la[i])
}
maa <- array()
for (i  in 1:11){
maa[i] <- JointSol(y,x,lambda = la[i])
}
maa
maa <- array()
maas < array()
maas < array()
maas <- array()
for (i  in 1:11){
maa[i] <- JointSol(y,x,lambda = la[i])$Phi
maas[i] <- JointSol(y,x,lambda = la[i])$P
}
maa
maas
maa <- JointSol(y,x,lambda=0.15)
maa
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
fdml <- dmlpath(y,x,lambda = la)
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
fdml <- dmlpath(y,x,lambda = la)
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
fdml <- dmlpath(y,x,lambda = la)
fdml
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
# perform cross validation
dml.cv <- cvdmlpath(y,x,lambda = la)
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
# perform cross validation
dml.cv <- cvdmlpath(y,x,lambda = la)
?vector
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
# perform cross validation
dml.cv <- cvdmlpath(y,x,lambda = la)
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
# perform cross validation
dml.cv <- cvdmlpath(y,x,lambda = la)
# perform cross validation
dml.cv <- cvdmlpath(y,x,lambda = la)
fdml$coef
class(fdml$coef)
# fit dmlpath
la <- seq(0.05,0.3,length=11)
fdml <- dmlpath(y,x,lambda = la)
fdml
Phi <- beta %*% (covar%^%{-1/2})
P <- covar%^%{-1/2}
Phi
beta
#fit dml
fit <- JointSol(y,x,lambda=0.05)
fit$Phi
fdml
fdml
class(fdml)
names(fdml)
class(fdml$coef)
dim(fdml$coef)
head(fdml$coef)
fdml$$coef[,,1]
fdml$coef[,,1]
class(fdml$coef)
names(fdml)
fdml$covar
dim(fdml$covar)
apply(fdml$coef, 3, head)
mapply(function(x) x[1:10,], fdml$coef, SIMPLIFY=FALSE)
mapply(function(x) x[1:10,,], fdml$coef, SIMPLIFY=FALSE)
apply(fdml$coef, 3, function(x) x[1:10,,])
apply(fdml$coef, 3, function(x) x[1:10,])
apply(fdml$coef, 3, function(x) x[1:10,1])
fdml$covar[,,1]
apply(fdml$coef, 3, function(x) x[1:10,1])
apply(fdml$coef, 3, function(x) x[1:10,2])
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
fdml <- dmlpath(y,x,lambda = la)
fdml <- dmlpath(y,x,lambda = la)
source('~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized/cv_dml.R', echo=TRUE)
fdml <- dmlpath(y,x,lambda = la)
apply(fdml$Phi, 3, function(x) x[1:10,1])
apply(fdml$Phi, 3, function(x) x[1:10,2])
fmdl$P
fdml$P
class(fdml$P)
apply(fdml$P, 3, eigen)
#fit dml
fit <- JointSol(y,x,lambda=0.05)
fit$Phi
n <- 10   # nr of observation
p <- 80  # nbr of component of x
m  <- 2 # nbr of component of y
k <- 1
#x <- cbind(rep(1,n),matrix(rnorm(n*p),n,p))
x <- matrix(rnorm(n*p),n,p)
prob = 1
beta <- array(0, dim = c(p,m))
rm(list=ls())
setwd("~/Documents/Research /BCM-GEM Algorithm/DML_reparametrized")
gc(TRUE)
"%^%" =  function(x, n)
mvsim <- function(x,prob,beta,covar){
n = dim(x)[1]
m = ncol(covar)
y = matrix(0,n,m)
for (i in 1:n){
y[i,] = rmvnorm(1,mean=x[i,]%*%beta,sigma=covar)
}
y
}
set.seed(13)
n <- 10   # nr of observation
p <- 80  # nbr of component of x
m  <- 2 # nbr of component of y
k <- 1
#x <- cbind(rep(1,n),matrix(rnorm(n*p),n,p))
x <- matrix(rnorm(n*p),n,p)
prob = 1
beta <- array(0, dim = c(p,m))
#beta[,,1] <- rbind(c(0,0),c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
beta <- rbind(c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
covar <- array(0, dim = c(m,m))
covar <- matrix(c(2,1,1,2),2,2)
Phi <- beta %*% (covar%^%{-1/2})
P <- covar%^%{-1/2}
Phi <- beta %*% (covar%^%{-1/2})
Phi <- beta %*% P
is.matrix(beta)
Phi <- beta%*%P
Phi <- beta%*%P
is.matrix(P)
P
covar <- array(0, dim = c(m,m))
covar <- matrix(c(2,1,1,2),2,2)
P <- covar%^%{-1/2}
P
covar
P <- covar^{-1/2}
P
P%*%P
P <- covar%^%{-1/2}
Pos <- covar%^%{-1/2}
Pos
chol(P)
chol(covar)
y <- mvsim(x=x,covar=covar,beta=beta,prob=prob)
mvsim <- function(x,prob,beta,covar){
n = dim(x)[1]
m = ncol(covar)
y = matrix(0,n,m)
for (i in 1:n){
y[i,] = rmvnorm(1,mean=x[i,]%*%beta,sigma=covar)
}
y
}
y <- mvsim(x=x,covar=covar,beta=beta,prob=prob)
source ("mvnorm.R")
y <- mvsim(x=x,covar=covar,beta=beta,prob=prob)
lambda =0.05
Y = y
X =x
N = dim(Y)[1]
M = dim(Y)[2]
P = dim(X)[2]
cent.Y = matrix(NA,N,M)
cent.X = matrix(NA,N,P)
cent.Y = Y - matrix(rep(colMeans(Y),each=N),N,M)
cent.X = X - matrix(rep(colMeans(X),each=N),N,P)
## Initial P
init.P = (t(cent.Y)%*%cent.Y)^{-0.5}/N
W = matrix(1,P,M)
init.Phi = matrix(0,P,M)
init.YP = cent.Y %*% init.P
for(i in 1:M){
lasso = lars(cent.X,init.YP[,i],use.Gram=FALSE,intercept=FALSE)
init.Phi[,i] = predict.lars(lasso,cent.X,lambda/2,type="coefficients",mode="lambda")$coefficients
}
init.Phi
## Updating_PhiP
output = JointLasso(cent.Y,cent.X,init.Phi,init.P,W,lambda)
JointLasso = function(cent.Y,cent.X,init.Phi,init.P,W,lambda1){
y<-cent.Y%*%init.P #1.should it be centralized?
#2. no glasso for P initialization
cur.Phi = init.Phi
cur.P = init.P
update = Onetime_update(cent.Y,cent.X,cur.Phi,cur.P,W,lambda1)
updatePhi = update[["updatePhi"]]
updateP = update[["updateP"]]
maxDiff = max(max(abs(cur.Phi-updatePhi)),max(abs(cur.P-updateP)))
iter_n = 1
while(maxDiff > 1.0e-3 && iter_n < 10)
{
cur.Phi = updatePhi
cur.P = updateP
update = Onetime_update(cent.Y,cent.X,cur.Phi,cur.P,W,lambda1)
updatePhi = update[["updatePhi"]]
updateP = update[["updateP"]]
maxDiff = max(max(abs(cur.Phi-updatePhi)),max(abs(cur.P-updateP)))
iter_n = iter_n+1
}
return(list(P = updateP, Phi = updatePhi, iteration = iter_n))
}
## Updating_PhiP
output = JointLasso(cent.Y,cent.X,init.Phi,init.P,W,lambda)
cent.YP<-cent.Y%*%cur.P #1.should it be centralized?
Onetime_update = function(cent.Y,cent.X,cur.Phi,cur.P,W,lambda1){
N = dim(cent.Y)[1]
M = dim(cent.Y)[2]
P = dim(cent.X)[2]
dims = c(N,M,P)
cent.YP<-cent.Y%*%cur.P #1.should it be centralized?
## update P
A = t(cent.YP-cent.X%*%cur.Phi)%*%(cent.YP-cent.X%*%cur.Phi)/N
Cest = glasso(A,rho=0,penalize.diagonal=FALSE,wi.init=cur.P)
updateP = Cest$wi
## Update Phi #TASK2
updatePhi = numeric(P*M)
iteration = numeric(1)
dyn.load("UpdatePhi_rep.so")
output = .C("UpdatePhi",as.double(t(cent.YP)),as.double(t(cent.X)),as.double(t(cur.Phi)),as.integer(dims),
as.double(t(W)),as.double(lambda1),updatePhi=as.double(updatePhi),iteration=as.integer(iteration))
dyn.unload("UpdatePhi_rep.so")
updatePhi = matrix(output[["updatePhi"]],P,M,byrow=T)
return(list(updateP=updateP,updatePhi=updatePhi))
}
## Updating_PhiP
output = JointLasso(cent.Y,cent.X,init.Phi,init.P,W,lambda)
output
init.P
N = dim(Y)[1]
M = dim(Y)[2]
P = dim(X)[2]
cent.Y = matrix(NA,N,M)
cent.X = matrix(NA,N,P)
cent.Y = Y - matrix(rep(colMeans(Y),each=N),N,M)
cent.X = X - matrix(rep(colMeans(X),each=N),N,P)
## Estimating Phi and P
update_PhiC = function(lambda){
## Initial P
init.P = (t(cent.Y)%*%cent.Y)^{-0.5}/N
W = matrix(1,P,M)
## Initial Phi #TASK1
init.Phi = matrix(0,P,M)
init.YP = cent.Y %*% init.P
for(i in 1:M){
lasso = lars(cent.X,init.YP[,i],use.Gram=FALSE,intercept=FALSE)
init.Phi[,i] = predict.lars(lasso,cent.X,lambda/2,type="coefficients",mode="lambda")$coefficients
}
## Updating_PhiP
output = JointLasso(cent.Y,cent.X,init.Phi,init.P,W,lambda)
return(output)
}
result = update_PhiC(lambda)
rm(list=ls())
gc(TRUE)
source("JointSol_rep.R")
source ("mvnorm.R")
"%^%" =  function(x, n)
with(eigen(x), vectors %*% (values^n * t(vectors)))
mvsim <- function(x,prob,beta,covar){
n = dim(x)[1]
m = ncol(covar)
y = matrix(0,n,m)
for (i in 1:n){
y[i,] = rmvnorm(1,mean=x[i,]%*%beta,sigma=covar)
}
y
}
set.seed(13)
n <- 10   # nr of observation
p <- 80  # nbr of component of x
m  <- 2 # nbr of component of y
k <- 1
#x <- cbind(rep(1,n),matrix(rnorm(n*p),n,p))
x <- matrix(rnorm(n*p),n,p)
prob = 1
beta <- array(0, dim = c(p,m))
#beta[,,1] <- rbind(c(0,0),c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
beta <- rbind(c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
covar <- array(0, dim = c(m,m))
covar <- matrix(c(2,1,1,2),2,2)
P <- covar{-1/2}
Phi <- beta%*%P
y <- mvsim(x=x,covar=covar,beta=beta,prob=prob)
lambda =0.05
Y = y
X =x
#fit dml
fit <- JointSol(y,x,lambda=0.05)
fit
# fit dmlpath
la <- seq(0.05,0.3,length=11)
fdml <- dmlpath(y,x,lambda = la)
source("cv_dml.R")
fdml <- dmlpath(y,x,lambda = la)
apply(fdml$coef, 3, function(x) x[1:10,1])
apply(fdml$coef, 3, function(x) x[1:10,2])
# fit dmlpath
la <- seq(0.0001,0.3,length=21)
fdml <- dmlpath(y,x,lambda = la)
apply(fdml$coef, 3, function(x) x[1:10,1])
apply(fdml$coef, 3, function(x) x[1:20,1])
beta
# fit dmlpath
la <- seq(0.01,0.03,length=21)
fdml <- dmlpath(y,x,lambda = la)
apply(fdml$coef, 3, function(x) x[1:10,1])
n <- 500   # nr of observation
p <- 80  # nbr of component of x
m  <- 2 # nbr of component of y
k <- 1
#x <- cbind(rep(1,n),matrix(rnorm(n*p),n,p))
x <- matrix(rnorm(n*p),n,p)
prob = 1
beta <- array(0, dim = c(p,m))
#beta[,,1] <- rbind(c(0,0),c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
beta <- rbind(c(1,3),c(3,1),c(1,3),c(1,1),matrix(0, p-4, m))
covar <- array(0, dim = c(m,m))
covar <- matrix(c(2,1,1,2),2,2)
y <- mvsim(x=x,covar=covar,beta=beta,prob=prob)
# fit dmlpath
la <- seq(0.01,0.03,length=21)
fdml <- dmlpath(y,x,lambda = la)
apply(fdml$coef, 3, function(x) x[1:10,1])
# fit dmlpath
la <- seq(0.5,1.5,length=21)
fdml <- dmlpath(y,x,lambda = la)
apply(fdml$coef, 3, function(x) x[1:10,1])
